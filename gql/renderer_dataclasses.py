import os
from typing import cast, Union
from graphql import GraphQLSchema, GraphQLWrappingType, GraphQLNonNull, OperationDefinitionNode, NonNullTypeNode, \
    NamedTypeNode

from gql.config import Config
from gql.query_parser import ParsedQuery, MappingNode

FILE_HEADER = """
# AUTOGENERATED file. Do not Change!
from typing import Any, Callable, Mapping
from dataclasses import dataclass
from dataclasses_json import dataclass_json

from gql.clients import Client, AsyncIOClient

{custom_header}

"""

OPERATION_TEMPLATE = """
@dataclass_json
@dataclass(frozen=True)
class {name}:
    __QUERY__ = \"\"\"
        {query}
    \"\"\"
"""

OPERATION_EXEC_FUNC_TEMPLATE = """
@classmethod
def execute(cls, {vars_args}, on_before_callback: Callable[[Mapping[str, str], Mapping[str, str]], None] = None):
    client = Client('{url}')
    variables = {vars_dict}
    response_text = client.call(cls.__QUERY__, variables=variables, on_before_callback=on_before_callback)
    return cls.from_json(response_text)

# @classmethod
# async def execute_async(cls, {vars_args}, on_before_callback: Callable[[Mapping[str, str], Mapping[str, str]], None] = None):
#     client = AsyncClient('{url}')
#     variables = {vars_dict}
#     response_text = await client.call(cls.__QUERY__, variables=variables, on_before_callback=on_before_callback)
#     return cls.from_json(response_text)
"""


CLASS_TEMPLATE = """
@dataclass_json
@dataclass(frozen=True)
class {name}({parents}):
"""


class DataclassesRenderer:

    def __init__(self, schema: GraphQLSchema, config: Config):
        self.schema = schema
        self.config = config

    def render(self, parsed_data: ParsedQuery):
        # We sort fragment nodes to be first and operations to be last because of dependecies
        sorted_data = sorted(parsed_data.parsed, key=lambda node: 1 if node.node.kind == 'operation_definition' else 0)

        lines = []
        for node in sorted_data:
            for line in self.__do_render(node, indent=0):
                lines.append(line)

        return FILE_HEADER.format(custom_header=self.config.custom_header) + '\n'.join(lines)

    def render_common(self):
        # pylint:disable=no-self-use
        return ''

    def __do_render(self, node: MappingNode, indent=0):
        if node.node.kind == 'operation_definition':
            yield from self.__render_operation(node, indent=indent)

        elif node.node.kind == 'fragment_definition':
            yield from self.__render_python_class(node, indent=indent)

        elif node.node.kind == 'field':
            field_typename = self.__scalar_type_to_python(node.graphql_type) #f'{node.node.name.value.capitalize()}Response'

            if node.children or node.fragments:
                yield from self.__render_python_class(node, indent=indent)

            # render field
            yield f'{self.indent(indent)}{node.name}: {field_typename}'

    def __render_operation(self, node: MappingNode, indent: int = 0):
        assert node.node.kind == 'operation_definition'
        graphql_node = cast(OperationDefinitionNode, node.node)
        op_name = f'{graphql_node.operation.value.capitalize()}{graphql_node.name.value}'

        ind = self.indent(indent)
        ind1 = self.indent(indent+1)

        op_def = OPERATION_TEMPLATE.format(name=op_name, query=node.query)
        for line in op_def.split(os.linesep):
            yield ind + line

        yield from self.__render_python_class(node, indent=indent+1)

        yield ind1 + f'data: {node.name} = None'
        yield ind1 + 'errors: Any = None'

        # Execution functions
        variables = [(vdef.variable.name.value, self.__variable_type_to_python(vdef.type)) for vdef in graphql_node.variable_definitions]

        variables_arguments = ', '.join([f'{vdef.variable.name.value}: {self.__variable_type_to_python(vdef.type)}' for vdef in graphql_node.variable_definitions])
        variables_dict = '{' + ', '.join(f'"{name}": {name}' for name, _ in variables) + '}' if variables else 'None'

        for line in OPERATION_EXEC_FUNC_TEMPLATE.format(vars_args=variables_arguments, vars_dict=variables_dict, url=self.config.schema).split(os.linesep):
            yield ind1 + line


    def __render_python_class(self, node: MappingNode, indent: int = 0):
        graphql_type = node.graphql_type if not isinstance(node.graphql_type, GraphQLWrappingType) else node.graphql_type.of_type

        ind = self.indent(indent)
        ind1 = self.indent(indent+1)

        name = node.name if node.node.kind in ['operation_definition', 'fragment_definition'] else str(graphql_type)

        class_def = CLASS_TEMPLATE.format(name=name, parents=','.join(node.fragments))
        for line in class_def.split(os.linesep):
            yield ind + line

        if node.fragments and not node.children:
            # Class has no fields of its own, only derive from fragment
            yield ind1 + 'pass'
        elif node.children:
            for child in node.children:
                yield from self.__do_render(child, indent=indent + 1)

        yield '\n'

    @staticmethod
    def __scalar_type_to_python(scalar, default=None):
        nullable = True
        if isinstance(scalar, GraphQLNonNull):
            nullable = False
            scalar = scalar.of_type

        mapping = {
            'ID': 'str',
            'String': 'str',
            'Int': 'int',
            'Float': 'float',
            'Boolean': 'bool',
            'DateTime': 'str'  # TODO: add config for custom mapping of scalar -> curom python type
        }

        default = default or scalar
        mapping = mapping.get(str(scalar), default)
        return mapping if not nullable else f'{mapping} = None'

    @staticmethod
    def __variable_type_to_python(vartype: Union[NonNullTypeNode, NamedTypeNode]):
        nullable = True
        if isinstance(vartype, NonNullTypeNode):
            nullable = False
            vartype = vartype.type

        mapping = {
            'ID': 'str',
            'String': 'str',
            'Int': 'int',
            'Float': 'float',
            'Boolean': 'bool',
            'DateTime': 'str'
        }

        mapping = mapping.get(vartype.name.value, 'str')
        return mapping if not nullable else f'{mapping} = None'

    @staticmethod
    def indent(count: int):
        return ' ' * 4 * count
