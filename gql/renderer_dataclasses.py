import os
from graphql import GraphQLSchema, GraphQLWrappingType, GraphQLNonNull

from gql.query_parser import MappingNode

FILE_HEADER = """
# AUTOGENERATED file. Do not Change!
from typing import Any
from dataclasses import dataclass
from dataclasses_json import dataclass_json

"""

OPERATION_TEMPLATE = """
@dataclass_json
@dataclass(frozen=True)
class {name}:
"""

CLASS_TEMPLATE = """
@dataclass_json
@dataclass(frozen=True)
class {name}({parents}):
"""

class DataclassesRenderer:

    def __init__(self, schema: GraphQLSchema):
        self.schema = schema

    def render(self, parsed_data: [MappingNode]):
        # We sort fragment nodes to be first and operations to be last because of dependecies
        sorted_data = sorted(parsed_data, key=lambda node: 1 if node.node.kind == 'operation_definition' else 0)

        lines = []
        for node in sorted_data:
            for line in self.__do_render(node, indent=0):
                lines.append(line)

        return FILE_HEADER + '\n'.join(lines)

    def render_common(self):
        return ''

    def __do_render(self, node: MappingNode, indent=0):
        if node.node.kind == 'operation_definition':
            for l in self.__render_operation(node, indent=indent):
                yield l

        elif node.node.kind == 'fragment_definition':
            for l in self.__render_python_class(node, indent=indent):
                yield l

        elif node.node.kind == 'field':
            field_typename = self.__scalar_type_to_python(node.graphql_type) #f'{node.node.name.value.capitalize()}Response'

            if node.children or node.fragments:
                for l in self.__render_python_class(node, indent=indent):
                    yield l

            # render field
            yield f'{self.indent(indent)}{node.name}: {field_typename}'

    def __render_operation(self, node: MappingNode, indent: int = 0):
        assert node.node.kind == 'operation_definition'
        graphql_node = node.node
        op_name = f'{graphql_node.operation.value.capitalize()}{graphql_node.name.value}'

        i = self.indent(indent)
        i1 = self.indent(indent+1)

        op_def = OPERATION_TEMPLATE.format(name=op_name)
        for line in op_def.split(os.linesep):
            yield i + line

        for l in self.__render_python_class(node, indent=indent+1):
            yield l

        yield i1 + f'data: {node.name} = None'
        yield i1 + 'errors: Any = None'

    def __render_python_class(self, node: MappingNode, indent: int = 0):
        graphql_type = node.graphql_type if not isinstance(node.graphql_type, GraphQLWrappingType) else node.graphql_type.of_type

        i = self.indent(indent)
        i1 = self.indent(indent+1)

        name = node.name if node.node.kind in ['operation_definition', 'fragment_definition'] else str(graphql_type)

        class_def = CLASS_TEMPLATE.format(name=name, parents=','.join(node.fragments))
        for line in class_def.split(os.linesep):
            yield i + line

        if node.fragments and not node.children:
            # Class has no fields of its own, only derive from fragment
            yield i1 + 'pass'
        elif node.children:
            for child in node.children:
                for line in self.__do_render(child, indent=indent + 1):
                    yield line

        yield '\n'

    @staticmethod
    def __scalar_type_to_python(scalar, default=None):
        nullable = True
        if isinstance(scalar, GraphQLNonNull):
            nullable = False
            scalar = scalar.of_type

        mapping = {
            'ID': 'str',
            'String': 'str',
            'Int': 'int',
            'Float': 'float',
            'Boolean': 'bool',
            'DateTime': 'str'
        }

        default = default or scalar
        mapping = mapping.get(str(scalar), default)
        return mapping if not nullable else f'{mapping} = None'

    @staticmethod
    def indent(n: int):
        return ' ' * 4 * n
